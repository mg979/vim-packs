#!/usr/bin/env python3

import glob
import os
import re
import subprocess
import sys
import shutil
from time import sleep,time
import webbrowser

#------------------------------------------------------------------------------
# Global variables
#------------------------------------------------------------------------------


ACTIONS = [ 'list', 'update', 'status', 'verbose', 'web', 'git', 'exe', 'log',
            'move2opt', 'move2start', 'install', 'remotes', 'fetch', 'graph',
            'helptags', 'backup', 'restore', 'terminal']

ACTION          = ''
ASYNC           = True
COLOR           = os.name != 'nt'
DECO            = True
HAS_OUTPUT      = False
HELP            = False
INSTALL         = False
INSTDIR         = 'vpacks'
INSTOPT         = True
NO_OUTPUT       = False
ONLY_OPT        = False
ONLY_START      = False
PACKS           = {}
PROCESSING      = []
QUEUE           = []
SHALLOW         = True
SHOW_SIZE       = False
TIMEOUT         = 0
WARNINGS        = []

COLORS = {
    'darkred':     '\33[31m',
    'darkgreen':   '\33[32m',
    'darkyellow':  '\33[33m',
    'darkblue':    '\33[34m',
    'darkviolet':  '\33[35m',
    'darkcyan':    '\33[36m',
    'red':         '\33[91m',
    'green':       '\33[92m',
    'yellow':      '\33[93m',
    'blue':        '\33[94m',
    'violet':      '\33[95m',
    'cyan':        '\33[96m',
}

UP_TO_DATE = re.compile('Already up-to-date.')

SEP = os.sep.replace('\\', '\\\\')
_start_ = SEP + 'start' + SEP
_opt_ = SEP + 'opt' + SEP
_pack_ = SEP + 'pack' + SEP


#------------------------------------------------------------------------------
# Package class
#------------------------------------------------------------------------------


class Package():
    """Class for vim packages."""
    def __init__(self, name, pdir=None, restore_from_backup=False):
        self.name = name
        if restore_from_backup:
            self.path = BACKUPDIR + SEP + name
        elif pdir:
            self.path = PACKS['dirs'][pdir] + name
        else:
            self.path = PACKS['packs'][name]
        self.is_package, self.process = True, None
        self.timeout = TIMEOUT

    #--------------------------------------------------------------------------
    # class helpers: specific to this class
    #--------------------------------------------------------------------------

    def cmd(self, action):
        return {
                'verbose':  self.verbose,        'remotes': self.remotes,
                'git':      self.git,            'exe':     self.exe,
                'web':      self.web,            'status':  self.status,
                'backup':   self.backup,         'restore': self.restore,
                'helptags': self.helptags,
                }[action]()

    def packdir(self):
        return re.sub('('+_opt_+'|'+_start_+')' + self.name + '$', '', self.path)

    def is_opt(self):
        return re.search(_opt_ + self.name + '$', self.path)

    def is_start(self):
        return re.search(_start_ + self.name + '$', self.path)

    def shell(self, cmd):
        """Run a shell command, return stdout and stderr."""
        res = subprocess.run(cmd.split(' '), cwd=self.path,
                             stdout=subprocess.PIPE,
                             stderr=subprocess.PIPE)
        return [res.stdout.decode('utf-8'), res.stderr.decode('utf-8')]

    def async_shell(self, cmd):
        """Run a shell command asynchronously."""
        return subprocess.Popen(cmd.split(' '), cwd=self.path,
                                stdout=subprocess.PIPE,
                                stderr=subprocess.PIPE)

    def size(self):
        s = subprocess.run(['du', '-chs'], cwd=self.path,
                           stdout=subprocess.PIPE)
        return s.stdout.decode('utf-8').split('\n')[0].replace('\t.', '')

    def verbose_output(self, cmd, nl=False):
        n = '\n' if nl else ''
        name = '\n' + green(self.name) + ': ' + n
        if cmd[1]:
            return name + red(cmd[1]) + '\n'
        elif cmd[0]:
            c = cmd[0].replace('nothing to commit, working tree clean\n', '')
            return name + c

    def output(self, cmd, updating=False):
        """Merge stdout and stderr if updating packages, otherwise prioritize
        stderr. Return an empty string if no output at all."""
        if NO_OUTPUT:
            return ''

        name = "%-30s" % (self.name + ': ')
        out, err = cmd

        if err:
            if ( err[:5] == 'fatal' ):
                fatal = red('fatal')
                rest = re.sub('\..*', '.', err.split('\n')[0][5:])
                return name + fatal + rest + '\n'
            elif updating and re.search('http', err.splitlines()[0]):
                err += '\n'
            else:
                err = red(err.split('\n')[0])
                return name + err + '\n'

        if out:
            ok = False

            if ACTION == 'fetch':
                out = out.replace('Fetching ', '').split('\n')
                out = 'Fetching ' + ', '.join(out[:-1]) + '\n'
            elif ACTION == 'remotes':
                out = ', '.join(reversed(out.splitlines())) + '\n'
            else:
                if re.search(UP_TO_DATE, out):
                    out = green('ok') + '\n'
                    ok = True
            if updating:
                if not ok:
                    name = '\n' + color('cyan', name, bold=True)
                return name + out + err
            else:
                return name + out

        # neither stdout nor stderr
        return ''

    #--------------------------------------------------------------------------
    # class commands: methods names have their correspective in Packdir class
    #--------------------------------------------------------------------------

    def list(self, show_size=None):
        cmd = self.shell('git status --porcelain')
        left = "%-40s " if COLOR else "%-31s"
        fmt = left + "%-5s %10s\n"
        size = self.size() if (show_size is None and SHOW_SIZE) else ''
        if cmd[1]:
            vals = (red(self.name), red('ER'), size)
        elif cmd[0]:
            mod, unt = False, False
            for line in cmd[0].split('\n'):
                if not line:
                    continue
                if not mod:
                    mod = 'M' in line[:2]
                if not unt:
                    unt = '?' in line[:2]
            sig = 'M?' if (mod and unt) else ' M' if mod else ' ?'
            vals = (color('cyan', self.name), red(sig), size)
        else:
            fmt = "%-31s %-5s %10s\n"
            vals = (self.name, green('ok'), size)
        return fmt % vals

    def restore(self):
        """Move package from backup directory, into packages directory."""
        src = BACKUPDIR + SEP + self.name
        if not os.path.exists(src):
            return red(self.name) + ' not in the backup directory'
        dst = PACKS['vimdir'] + _pack_ + INSTDIR + _start_or_opt_()
        shutil.move(src, dst)
        return green(self.name) + ' moved into directory ' + dst + '\n'

    def backup(self):
        """Move package into the backup directory."""
        shutil.move(self.path, BACKUPDIR)
        return green(self.name) + ' moved into the backup directory\n'

    def helptags(self):
        """Update helptags for package."""
        docdir = (self.path + SEP + 'doc').replace(' ', '\ ')
        if os.path.isdir(docdir):
            subprocess.run(
                    'vim -nEs -c "silent! helptags %s | q"' % docdir, shell=True)

    def update(self):
        self.process = self.async_shell('git pull --ff-only')
        PROCESSING.append(self)
        if not ASYNC:
            wait(self)

    def terminal(self):
        subprocess.run(
            ['exo-open', '--launch', 'TerminalEmulator',
             '--working-directory', '%s' % self.path.replace(' ', '\ ')])

    def status(self):
        cmd = self.shell('git status --porcelain')
        name = green(self.name)
        if cmd[1]:
            return name + ': ' + red(cmd[1])
        elif cmd[0]:
            lines = [(red(line[:2]) + line[2:])
                     for line in cmd[0].splitlines()]
            return '\n' + name + ':\n' + '\n'.join(lines) + '\n'
        return ''

    def verbose(self):
        color = ' -c color.ui=always ' if COLOR else ' '
        return self.verbose_output(
            self.shell('git' + color + 'status -vv'))

    def remotes(self):
        return self.output(self.shell('git remote'))

    def git(self):
        color = ' -c color.ui=always ' if COLOR else ' '
        return self.verbose_output(
            self.shell('git' + color + EXE), nl=True)

    def exe(self):
        return self.verbose_output(self.shell(EXE), nl=True)

    def web(self):
        try:
            remote = self.shell('git remote')[0].splitlines()[0]
            url = self.shell('git remote get-url ' + remote)[0].splitlines()[0]
        except IndexError:
            return red('fatal') + ": no web page for " + self.name
        subprocess.run("python -m webbrowser '%s'" % url, shell=True,
                       stderr=subprocess.PIPE, stdout=subprocess.PIPE)

    def fetch(self):
        self.process = self.async_shell('git fetch --all')
        PROCESSING.append(self)
        if not ASYNC:
            wait(self)

    def move2opt(self, silent=False):
        name = green(self.name)
        pdir = self.packdir()
        if name == 'vim-packs':
            log(name + " will not be moved")
        if self.is_opt():
            log(name + " is already in /opt")
        else:
            log("Moving " + name + " to /opt")
            subprocess.run(['mv', self.path, pdir + _opt_])
            PACKS['packs'][self.name] = pdir + _opt_ + self.name
        if not NO_OUTPUT and not silent:
            Packdir(os.path.basename(pdir)).list(show_size=False)

    def move2start(self, silent=False):
        name = green(self.name)
        pdir = self.packdir()
        if name == 'vim-packs':
            log(name + " will not be moved")
        if self.is_start():
            log(name + " is already in /start")
        else:
            log("Moving " + name + " to /start")
            subprocess.run(['mv', self.path, pdir + _start_])
            PACKS['packs'][self.name] = pdir + _start_ + self.name
        if not NO_OUTPUT and not silent:
            Packdir(os.path.basename(pdir)).list(show_size=False)


#------------------------------------------------------------------------------
# Package directory class
#------------------------------------------------------------------------------


class Packdir():
    """Class for base package directories."""
    def __init__(self, name):
        self.name = name
        if name in PACKS['dirs']:
            self.path = PACKS['dirs'][name]
        else:
            self.path = PACKS['dirs'][name] = PACKS['vimdir'] + _pack_ + name
        self.is_package = False
        self.has_output_opt = False
        self.has_output_start = False

    #--------------------------------------------------------------------------
    # class helpers: specific to this class
    #--------------------------------------------------------------------------

    def ensure_exists(self):
        if os.path.exists(self.path) and not os.path.isdir(self.path):
            error("Path exists and is not a directory, aborting.")
        if not os.path.exists(self.path):
            if not confirm("Create directories in " + self.path):
                error("Invalid directory, aborting.")
            os.makedirs(self.path + _opt_)
            os.makedirs(self.path + _start_)
        if not os.path.exists(self.path + _opt_):
            os.makedirs(self.path + _opt_)
        if not os.path.exists(self.path + _start_):
            os.makedirs(self.path + _start_)

    def has(self, pack, in_opt=False, in_start=False):
        """Check if package is contained in this packdir."""
        if not in_start:
            for p in self.walk(_opt_):
                if os.path.basename(p) == pack:
                    return p
        if not in_opt:
            for p in self.walk(_start_):
                if os.path.basename(p) == pack:
                    return p

    def header(self, path):
        if ( not DECO or not os.path.exists(path) or not os.listdir(path) ):
            return
        if COLOR:
            blue, yelw, end, bold = ("\33[34m", "\33[33m", "\33[0m", "\33[1m")
            log("\n" + blue + "─" * 67 + end)
            log(bold + blue + "Packs in directory " + yelw + path + end)
            log(blue + "─" * 67 + end + "\n")
        else:
            log("\n" + "-" * 67)
            log("Packs in directory " + path)
            log("-" * 67 + "\n")

    def walk(self, subdir):
        if ( ONLY_OPT and subdir == _start_ ):
            return []
        if ( ONLY_START and subdir == _opt_ ):
            return []
        if ( os.path.exists(self.path + subdir) ):
            return glob.iglob(self.path + subdir + '*')
        return []

    def output(self, output, subdir):
        """Print the header only if there's some package to display."""
        if ( NO_OUTPUT or not output ):
            return
        if ( not self.has_output_opt and subdir==_opt_ and not ONLY_START ):
            self.has_output_opt = True
            self.header(self.path + _opt_)
        if ( not self.has_output_start and subdir==_start_ and not ONLY_OPT ):
            self.has_output_start = True
            self.header(self.path + _start_)
        log(output, end='')

    def install(self, repo):
        if not self.has(repo.name):
            packdir = self.path + _start_or_opt_()
            cmd = ['git', 'clone', '--recursive']
            if SHALLOW:
                cmd.append('--depth')
                cmd.append('1')
                cmd.append('--shallow-submodules')
            repo.process = subprocess.Popen(
                cmd + [repo.address],
                cwd=packdir,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT
            )
            repo.path = packdir + repo.name
            PROCESSING.append(repo)
            if not ASYNC:
                wait(repo)

    #--------------------------------------------------------------------------
    # class commands: methods names have their correspective in Package class
    #--------------------------------------------------------------------------

    def verbose(self):  self.cmd('verbose')
    def remotes(self):  self.cmd('remotes')
    def git(self):      self.cmd('git')
    def exe(self):      self.cmd('exe')
    def web(self):      self.cmd('web')
    def status(self):   self.cmd('status')
    def helptags(self): self.cmd('helptags')
    def backup(self):   self.cmd('backup')
    def restore(self):  self.cmd('restore')

    def cmd(self, action):
        for p in self.walk(_opt_):
            self.output(Package(os.path.basename(p)).cmd(action), _opt_)
        for p in self.walk(_start_):
            self.output(Package(os.path.basename(p)).cmd(action), _start_)

    def terminal(self):
        error('terminal: not allowed for pack directories')

    def list(self, show_size=None):
        for p in self.walk(_opt_):
            self.output(Package(os.path.basename(p)).list(show_size), _opt_)
        for p in self.walk(_start_):
            self.output(Package(os.path.basename(p)).list(show_size), _start_)

    def update(self):
        for p in self.walk(_opt_):
            Package(os.path.basename(p)).update()
        process_asynch(self, _opt_)
        for p in self.walk(_start_):
            Package(os.path.basename(p)).update()
        process_asynch(self, _start_)

    def fetch(self):
        for p in self.walk(_opt_):
            Package(os.path.basename(p)).fetch()
        process_asynch(self, _opt_)
        for p in self.walk(_start_):
            Package(os.path.basename(p)).fetch()
        process_asynch(self, _start_)

    def move2opt(self):
        opt = green(self.path + _opt_)
        start = green(self.path + _start_)
        if confirm("Move all packages in " + start + "\n%21s" % "to " + opt):
            os.makedirs(self.path + _opt_, exist_ok=True)
            for p in self.walk(_start_):
                Package(os.path.basename(p)).move2opt(silent=True)
            self.list(show_size=False)

    def move2start(self):
        opt = green(self.path + _opt_)
        start = green(self.path + _start_)
        if confirm("Move all packages in " + opt + "\n%21s" % "to " + start):
            os.makedirs(self.path + _start_, exist_ok=True)
            for p in self._walk(_opt_):
                Package(os.path.basename(p)).move2start(silent=True)
            self.list(show_size=False)


#------------------------------------------------------------------------------
# Repository class
#------------------------------------------------------------------------------


class Repo():
    """Class for remote repositories."""
    def __init__(self, arg):
        self.arg = arg
        self.name = None
        self.path = None
        self.user = None
        self.address = None
        self.process = None
        self.timeout = TIMEOUT

    def validate(self):
        """Fill repo information. If repo is valid, return success."""
        gh = 'https://github.com/'
        gl = 'https://gitlab.com/'

        try:
            pack = self.arg.split('/')

            if len(pack) == 2:
                self.user, self.name = pack
                self.address = gh + self.arg

            elif len(pack) == 3:
                site, self.user, self.name = pack
                if site == 'gh':
                    self.address = (gh + self.user + '/' + self.name)
                elif site == 'gl':
                    self.address = (gl + self.user + '/' + self.name)
                else:
                    return False

            elif re.search('^https?://', self.arg):
                self.address = re.sub('/?$', '', self.arg)
                self.name = re.sub('.*/|(\.git)?/?$', '', self.address)
                self.user = re.match('.*/([^/]+)/', self.address).group(1)
        except:
            return False
        return self.address


#------------------------------------------------------------------------------
# HELP
#------------------------------------------------------------------------------


def print_help():
    """Print the help and exit."""
    commands = [
        ['list',        'list packages'],
        ['update',      'update packages'],
        ['install',     'install packages from remote repos'],
        ['status',      'list only packages with a dirty working tree'],
        ['verbose',     'verbose status (with diff)'],
        ['remotes',     'list remotes for packages'],
        ['fetch',       'fetch all remotes'],
        ['terminal',    'open a new terminal at package directory'],
        ['helptags',    'update helptags for package(s)'],
        ['backup',      'move/list package(s) to the backup directory'],
        ['restore',     'restore/list package(s) from the backup directory'],
        ['log [-n]',    'log the last (-n) commit(s) for repo(s)'],
        ['graph [-n]',  'log the graph of the commit history for repo(s)'],
        ['git',         'run a single, quoted git command'],
        ['exe',         'run a single, quoted command of any type'],
        ['web',         'open web page, if possible'],
        ['move2opt',    'move package(s) into the /opt directory'],
        ['move2start',  'move package(s) into the /start directory'],
    ]

    if not HELP:
        commands = commands[:5]

    options = [
        ['-h',          'extended help'],
        ['-nd',         'no decorations (color, headers)'],
        ['-nc',         'no color'],
        ['-no',         'no output (for use inside scripts)'],
        ['-na',         'no async update/cloning'],
        ['-ps',         'print size for "list" subcommand'],
        ['-time',       'timeout in seconds for operations (default 0)'],
        ['-full',       'do not make shallow clones'],
        ['-opt',        'command only considers opt packages'],
        ['-start',      'command only considers start packages'],
    ]

    options = options[:4] if not HELP else options[1:]

    instopts = [
        ['start',       'install in /start directory rather than in /opt'],
        ['opt',         'install in /opt directory rather than in /start'],
        ['dir=DIR',     'set base installation directory for packages'],
    ]

    examples = [
        ['List all packages in the pack/my_packs/*/* directories',
         'vpacks list my_packs'],
        ['Verbose status for selected packages',
         'vpacks verbose visual-multi yanktools'],
        ['Run git command',
         'vpacks git "branch --list" my_packs'],
        ['Install a package in the default ("vpacks") directory, as opt type',
         'vpacks install opt mg979/visual-multi'],
        ['Install packages in specific directory',
         'vpacks install dir=my_packs mg979/visual-multi'],
    ]

    print()
    print("Usage:\tvpacks [options] COMMAND [pack | directory]")
    print("\tvpacks [options] install [instopts] REPOS")
    print()
    print("Commands:")
    for c in commands:
        print("\t" + "%-20s" % green(c[0]) + c[1])
    print()
    print("Options:")
    for o in options:
        print("\t" + "%-20s" % green(o[0]) + o[1])
    print()
    print("Installation options:")
    for o in instopts:
        print("\t" + "%-20s" % green(o[0]) + o[1])
    print()
    print("Examples:")
    print()
    for e in examples:
        print('\t' + e[0] + '\n\t' + color('darkgreen', e[1]) + '\n')
    sys.exit()


#------------------------------------------------------------------------------
# GENERIC HELPERS
#------------------------------------------------------------------------------


def error(string):
    """Print an error and exit."""
    print(string)
    sys.exit()


def color(color, string, bold=False, line=False):
    """Print a colored string."""
    if not COLOR:
        return string
    b = '\033[1m' if bold else ''
    l = '\033[4m' if line else ''
    return COLORS[color] + b + l + string + '\033[0m'


def green(string):
    return color('green', string)


def red(string):
    return color('red', string)


def log(string, end='\n'):
    """Print output if allowed."""
    if not NO_OUTPUT and string:
        if os.name == 'nt':
            string = string.replace('\\\\', '\\')
        print(string, end=end)


def confirm(string):
    """Always return True with -no option."""
    if NO_OUTPUT:
        return True
    print(string + '    ? (y/n)')
    return sys.stdin.read(1) == 'y'


def warning(msg, pack):
    """Issue a warning related to some package."""
    if NO_OUTPUT:
        return True
    log(red('Warning') + ': ' + msg + ' (' + pack + ')')


def find_packs():
    """Find vim and package directories and basenames."""
    global WARNINGS, BACKUPDIR
    win             = os.path.expanduser('~\\vimfiles').replace('\\', '\\\\')
    nwin            = os.path.expanduser('~/.vim')
    PACKS['vimdir'] = win if os.path.exists(win) else nwin
    BACKUPDIR       = PACKS['vimdir'] + _pack_ + 'backup'
    dirpaths        = glob.glob(PACKS['vimdir'] + _pack_ + '*')
    PACKS['dirs']   = {os.path.basename(folder): folder for folder in dirpaths}

    if 'backup' in PACKS['dirs']:
        del PACKS['dirs']['backup']

    bdir            = re.compile(BACKUPDIR)
    packpaths       = glob.glob(PACKS['vimdir'] + _pack_ + '*%s*%s*' % (SEP, SEP))
    packpaths       = list(filter(lambda pdir: not re.search(bdir, pdir), packpaths))
    PACKS['packs']  = {}

    for packpath in packpaths:
        key = os.path.basename(packpath)
        if key in PACKS['packs']:
            WARNINGS.append(('duplicated package', key))
        else:
            PACKS['packs'][key] = packpath

    for dir in PACKS['dirs']:
        for pack in PACKS['packs']:
            if pack == dir:
                msg = 'a package with the same name of a directory exists'
                WARNINGS.append((msg, pack))


def _start_or_opt_():
    """Return /start/ or /opt/, with os separators."""
    return _opt_ if INSTOPT else _start_


def list_backup_dir():
    backups = os.listdir(BACKUPDIR)
    if not backups:
        log('No packages in the backup directory.')
    elif COLOR:
        blue, yelw, end, bold = ("\33[34m", "\33[33m", "\33[0m", "\33[1m")
        log("\n" + blue + "─" * 67 + end)
        log(bold + blue + "Packs in directory " + yelw + BACKUPDIR + end)
        log(blue + "─" * 67 + end + "\n")
    elif DECO:
        log("\n" + "─" * 67)
        log("Packs in directory " + BACKUPDIR)
        log("─" * 67 + "\n")
    for pack in backups:
        log(pack)
    sys.exit()


def wait(pack):
    """Wait for process to terminate, handle TimeoutError."""
    try:
        pack.process.wait(timeout=TIMEOUT)
    except TimeoutError:
        warn_timeout(pack.name)


def warn_timeout(name):
    """Log warning when timeout has been reached."""
    log("%-30s" % (name + ': ') + red("timeout %ds" % int(TIMEOUT)))


#------------------------------------------------------------------------------
# COMMAND-LINE ARGUMENTS PARSING
#------------------------------------------------------------------------------


def walk_arg(arg):
    """Process arguments and build actions queue."""
    if ( arg in PACKS['dirs'] ):
        QUEUE.append(Packdir(arg))
    elif ( arg in PACKS['packs'] ):
        QUEUE.append(Package(arg))
    else:
        error('Pack or pack directory not found.')


def parse_args():
    """Parse arguments."""
    global ACTION, DECO, SHOW_SIZE, NO_OUTPUT, INSTALL, ASYNC, EXE, COLOR, HELP
    global TERMINAL, ONLY_START, ONLY_OPT, TIMEOUT, SHALLOW
    args = sys.argv[1:]

    while ( args ):
        if (args[0] in ['-h', '-nd', '-nc', '-ps', '-no',
                        '-full', '-opt', '-start']):

            if   ( args[0] == '-h'      ): HELP = True
            elif ( args[0] == '-nd'     ): DECO = False
            elif ( args[0] == '-nc'     ): COLOR = False
            elif ( args[0] == '-ps'     ): SHOW_SIZE = True
            elif ( args[0] == '-no'     ): NO_OUTPUT = True
            elif ( args[0] == '-full'   ): SHALLOW = False
            elif ( args[0] == '-opt'    ): ONLY_OPT = True
            elif ( args[0] == '-start'  ): ONLY_START = True

            del args[0]
            continue

        if ( args[0] == '-na' ):
            ASYNC = False
            del args[0]
            continue

        if ( args[0] == '-time' ):
            del args[0]
            if ( args ):
                TIMEOUT = int(args.pop(0))
                continue
            else:
                print_help()

        # exit loop when the first arg is found, that isn't an option
        break

    if ( not args ):
        print_help()

    ACTION = args.pop(0)
    TERMINAL = sys.stdout.isatty()
    COLOR = not NO_OUTPUT and COLOR and DECO

    if ( ACTION not in ACTIONS ):
        print_help()

    elif ( ACTION == 'install' ):
        INSTALL = True
        parse_install(args)
        return

    elif ( ACTION == 'backup' ):
        os.makedirs(BACKUPDIR, exist_ok=True)
        if ( not args ):
            list_backup_dir()

    elif ( ACTION == 'restore' ):
        os.makedirs(BACKUPDIR, exist_ok=True)
        parse_restore(args)
        return

    elif ( ACTION == 'log' ):
        n = args.pop(0) if ( args and re.search('-\d+', args[0]) ) else '-1'
        EXE = 'log %s --' % n

    elif ( ACTION == 'graph' ):
        n = args.pop(0) if ( args and re.search('-\d+', args[0]) ) else ''
        EXE = 'log %s --graph --oneline --' % n

    elif ( ACTION in ['git', 'exe'] ):
        if ( not args ):
            print_help()
        EXE = args.pop(0)


    # if no args beyond the command, perform on all packages, in all dirs
    # otherwise perform on args (they could be single packages, or directories)
    if ( not args ):
        for path in glob.iglob(PACKS['vimdir'] + _pack_ + '*'):
            if os.path.basename(path) == 'backup':
                continue
            walk_arg(os.path.basename(path))
    else:
        for arg in args:
            walk_arg(arg)


def parse_install(args):
    """Parse arguments that follow an 'install' subcommand."""
    global INSTDIR, INSTOPT
    for arg in args:
        if ( arg == 'opt' ):
            INSTOPT = True
        elif ( arg == 'start' ):
            INSTOPT = False
        elif ( re.search('^dir=\w+', arg) ):
            INSTDIR = arg.replace('dir=', '')
        else:
            QUEUE.append(arg)


def parse_restore(args):
    """Parse arguments that follow an 'restore' subcommand."""
    global INSTDIR, INSTOPT
    if not args:
        list_backup_dir()
    for arg in args:
        if ( arg == 'opt' ):
            INSTOPT = True
        elif ( arg == 'start' ):
            INSTOPT = False
        elif ( re.search('^dir=\w+', arg) ):
            INSTDIR = arg.replace('dir=', '')
        else:
            QUEUE.append(Package(arg, restore_from_backup=True))


#------------------------------------------------------------------------------
#   INSTALL QUEUE PROCESSING
#------------------------------------------------------------------------------


def clone_output(out):
    if ( re.search('\nfatal:', out) ):
        return re.sub('fatal:', red('fatal') + ':', out)
    else:
        return out


def process_clones():
    """Handle asynch package installation."""
    start = time()
    while ( PROCESSING ):
        i = 0

        # --------------------

        for repo in PROCESSING:
            if TIMEOUT and repo.timeout < 0:
                warn_timeout(repo.name)
                repo.process.terminate()
                del PROCESSING[i]
                break
            if repo.process.poll() is not None:
                out = repo.process.communicate()[0].decode('utf-8')
                name = green(repo.user + '/' + repo.name)
                log(name + ': ' + clone_output(out))
                PACKS['packs'][repo.name] = repo.path
                Package(repo.name).helptags()
                del PROCESSING[i]
                break
            if TIMEOUT:
                passed = time() - start
                repo.timeout -= passed
                start += passed
            i += 1

        # --------------------

        if ( PROCESSING ):
            sleep(0.2)


def install_packages():
    """Process the install queue."""
    pdir = Packdir(INSTDIR)
    pdir.ensure_exists()
    instdir = pdir.path + _start_or_opt_()

    for q in QUEUE:
        repo = Repo(q)
        if not repo.validate():
            log(q + ' is not a valid argument')
            continue

        if repo.name in PACKS['packs']:
            name = green(repo.user + '/' + repo.name)
            dr = PACKS['packs'][repo.name].replace(PACKS['vimdir'], '')
            log(name + ': already installed in ..' + dr)
        elif not pdir.has(repo.name):
            pdir.install(repo)
        else:
            name = green(repo.user + '/' + repo.name)
            log(name + ': already installed in ' + pdir.path)

    process_clones()


#------------------------------------------------------------------------------
#   ACTION QUEUE PROCESSING
#------------------------------------------------------------------------------


def process_asynch(packdir=None, subdir=None):
    """Handle asynch package processing."""
    update = ACTION == 'update'
    start = time()
    while ( PROCESSING ):
        i = 0

        # --------------------

        for pack in PROCESSING:
            if TIMEOUT and pack.timeout < 0:
                warn_timeout(pack.name)
                pack.process.terminate()
                del PROCESSING[i]
                break
            if pack.process.poll() is not None:
                cmd = pack.process.communicate()
                cmd = [cmd[0].decode('utf-8'), cmd[1].decode('utf-8')]
                if packdir:
                    # output is managed by Packdir class
                    packdir.output(pack.output(cmd, updating=update), subdir)
                else:
                    # query for single packs, no Packdir calls
                    log(pack.output(cmd, updating=update))
                pack.helptags()
                del PROCESSING[i]
                break
            if TIMEOUT:
                passed = time() - start
                pack.timeout -= passed
                start += passed
            i += 1

        # --------------------

        if ( PROCESSING ):
            sleep(0.2)


def process_action():
    """
    Process the queue for the requested action.

    Each element of the queue is either a packages directory, or a single
    package. Their public methods' names are the same, so they can be called in
    either case.
    """
    for q in QUEUE:
        actions = {
            'list':     q.list,          'update':     q.update,
            'status':   q.status,        'verbose':    q.verbose,
            'remotes':  q.remotes,       'fetch':      q.fetch,
            'move2opt': q.move2opt,      'move2start': q.move2start,
            'git':      q.git,           'exe':        q.exe,
            'log':      q.git,           'graph':      q.git,
            'web':      q.web,           'helptags':   q.helptags,
            'backup':   q.backup,        'restore':    q.restore,
            'terminal': q.terminal,
        }
        log ( actions[ACTION]() )

    # packages may have been queued for async processing
    process_asynch()


#------------------------------------------------------------------------------
#   MAIN QUEUE PROCESSING
#------------------------------------------------------------------------------


def main():
    """Main function."""
    find_packs()            # find packages and their directories
    parse_args()            # build the action/installation queue

    if INSTALL:
        install_packages()
    else:
        process_action()

    if not NO_OUTPUT:       # leave an empty line at the end
        print()

    for msg in WARNINGS:
        warning(msg[0], msg[1])


if __name__ == '__main__':
    main()

