#!/usr/bin/env python3

import glob
import os
import re
import subprocess
import sys
from shutil import which
from time import sleep,time

#------------------------------------------------------------------------------
# Global variables
#------------------------------------------------------------------------------


ACTIONS = [ 'list', 'update', 'status', 'verbose', 'fetch', 'git', 'exe',
            'move2opt', 'move2start', 'install', 'remotes' ]

ACTION          = ''
ASYNC           = True
COLOR           = os.name != 'nt'
DECO            = True
HAS_OUTPUT      = False
HELP            = False
INSTALL         = False
INSTDIR         = 'vpacks'
INSTOPT         = False
NO_OUTPUT       = False
ONLY_OPT        = False
ONLY_START      = False
PACKS           = {}
PROCESSING      = []
QUEUE           = []
SHOW_SIZE       = False
TIMEOUT         = 15
WARNINGS        = []

COLORS = {
    'darkred':     '\33[31m',
    'darkgreen':   '\33[32m',
    'darkyellow':  '\33[33m',
    'darkblue':    '\33[34m',
    'darkviolet':  '\33[35m',
    'darkcyan':    '\33[36m',
    'red':         '\33[91m',
    'green':       '\33[92m',
    'yellow':      '\33[93m',
    'blue':        '\33[94m',
    'violet':      '\33[95m',
    'cyan':        '\33[96m',
}

UP_TO_DATE = re.compile('Already up-to-date.')


#------------------------------------------------------------------------------
# Package class
#------------------------------------------------------------------------------


class Package():
    """Class for vim packages."""
    def __init__(self, name, pdir=None):
        self.name = name
        if pdir:
            self.path = PACKS['dirs'][pdir] + '/' + name
        else:
            self.path = PACKS['packs'][name]
        self.is_package, self.process = True, None
        self.timeout = TIMEOUT

    #--------------------------------------------------------------------------
    # class helpers: specific to this class
    #--------------------------------------------------------------------------

    def packdir(self):
        return re.sub('/(opt|start)/' + self.name + '$', '', self.path)

    def is_opt(self):
        return re.search('opt/' + self.name + '$', self.path)

    def is_start(self):
        return re.search('start/' + self.name + '$', self.path)

    def shell(self, cmd):
        """Run a shell command, return stdout and stderr."""
        res = subprocess.run(cmd.split(' '), cwd=self.path,
                             stdout=subprocess.PIPE,
                             stderr=subprocess.PIPE)
        return [res.stdout.decode('utf-8'), res.stderr.decode('utf-8')]

    def async_shell(self, cmd):
        """Run a shell command asynchronously."""
        return subprocess.Popen(cmd.split(' '), cwd=self.path,
                                stdout=subprocess.PIPE,
                                stderr=subprocess.PIPE)

    def size(self):
        s = subprocess.run(['du', '-chs'], cwd=self.path,
                           stdout=subprocess.PIPE)
        return s.stdout.decode('utf-8').split('\n')[0].replace('\t.', '')

    def verbose_output(self, cmd, nl=False):
        n = '\n' if nl else ''
        name = '\n' + color('green', self.name) + ': ' + n
        if cmd[1]:
            return name + color('red', cmd[1]) + '\n'
        elif cmd[0]:
            c = cmd[0].replace('nothing to commit, working tree clean\n', '')
            return name + c

    def output(self, cmd, updating=False):
        """Merge stdout and stderr if updating packages, otherwise prioritize
        stderr. Return an empty string if no output at all."""
        if NO_OUTPUT:
            return ''

        name = "%-30s" % (self.name + ': ')
        out, err = cmd

        if err:
            if ( err[:5] == 'fatal' ):
                fatal = color('red', 'fatal')
                rest = re.sub('\..*', '.', err.split('\n')[0][5:])
                return name + fatal + rest + '\n'
            elif updating and re.search('http', err.splitlines()[0]):
                err += '\n'
            else:
                err = color('red', err.split('\n')[0])
                return name + err + '\n'

        if out:
            ok = False

            if ACTION == 'fetch':
                out = out.replace('Fetching ', '').split('\n')
                out = 'Fetching ' + ', '.join(out[:-1]) + '\n'
            elif ACTION == 'remotes':
                out = ', '.join(reversed(out.splitlines())) + '\n'
            else:
                if re.search(UP_TO_DATE, out):
                    out = color('green', 'ok') + '\n'
                    ok = True
            if updating:
                if not ok:
                    name = '\n' + color('cyan', name, bold=True)
                return name + out + err
            else:
                return name + out

        # neither stdout nor stderr
        return ''

    #--------------------------------------------------------------------------
    # class commands: methods names have their correspective in Packdir class
    #--------------------------------------------------------------------------

    def list(self, show_size=None):
        cmd = self.shell('git status --porcelain')
        left = "%-40s " if COLOR else "%-31s"
        fmt = left + "%-5s %10s\n"
        size = self.size() if (show_size is None and SHOW_SIZE) else ''
        if cmd[1]:
            vals = (color('red', self.name), color('red', 'ER'), size)
        elif cmd[0]:
            mod, unt = False, False
            for line in cmd[0].split('\n'):
                if not line:
                    continue
                if not mod:
                    mod = 'M' in line[:2]
                if not unt:
                    unt = '?' in line[:2]
            sig = 'M?' if (mod and unt) else ' M' if mod else ' ?'
            vals = (color('cyan', self.name), color('red', sig), size)
        else:
            fmt = "%-31s %-5s %10s\n"
            vals = (self.name, color('green', 'ok'), size)
        return fmt % vals

    def update(self):
        self.process = self.async_shell('git pull --ff-only')
        PROCESSING.append(self)
        if not ASYNC:
            wait(self)

    def status(self):
        cmd = self.shell('git status --porcelain')
        name = color('green', self.name)
        if cmd[1]:
            return name + ': ' + color('red', cmd[1])
        elif cmd[0]:
            lines = [(color('red', line[:2]) + line[2:])
                     for line in cmd[0].splitlines()]
            return '\n' + name + ':\n' + '\n'.join(lines) + '\n'
        return ''

    def verbose(self):
        color = ' -c color.ui=always ' if COLOR else ' '
        return self.verbose_output(
            self.shell('git' + color + 'status -vv'))

    def remotes(self):
        return self.output(self.shell('git remote'))

    def git(self):
        color = ' -c color.ui=always ' if COLOR else ' '
        return self.verbose_output(
            self.shell('git' + color + EXE), nl=True)

    def exe(self):
        return self.verbose_output(self.shell(EXE), nl=True)

    def fetch(self):
        self.process = self.async_shell('git fetch --all')
        PROCESSING.append(self)
        if not ASYNC:
            wait(self)

    def move2opt(self, silent=False):
        name = color('green', self.name)
        pdir = self.packdir()
        if self.is_opt():
            log(name + " is already in /opt")
        else:
            log("Moving " + name + " to /opt")
            subprocess.run(['mv', self.path, pdir + '/opt'])
            PACKS['packs'][self.name] = pdir + '/opt/' + self.name
        if not NO_OUTPUT and not silent:
            Packdir(os.path.basename(pdir)).list(show_size=False)

    def move2start(self, silent=False):
        name = color('green', self.name)
        pdir = self.packdir()
        if self.is_start():
            log(name + " is already in /start")
        else:
            log("Moving " + name + " to /start")
            subprocess.run(['mv', self.path, pdir + '/start'])
            PACKS['packs'][self.name] = pdir + '/start/' + self.name
        if not NO_OUTPUT and not silent:
            Packdir(os.path.basename(pdir)).list(show_size=False)


#------------------------------------------------------------------------------
# Package directory class
#------------------------------------------------------------------------------


class Packdir():
    """Class for base package directories."""
    def __init__(self, name):
        self.name = name
        if name in PACKS['dirs']:
            self.path = PACKS['dirs'][name]
        else:
            self.path = PACKS['dirs'][name] = PACKS['vimdir'] + '/pack/' + name
        self.is_package = False
        self.has_output_opt = False
        self.has_output_start = False

    #--------------------------------------------------------------------------
    # class helpers: specific to this class
    #--------------------------------------------------------------------------

    def ensure_exists(self):
        if ( not os.path.exists(self.path) ):
            os.makedirs(self.path + '/opt')
            os.makedirs(self.path + '/start')

    def has(self, pack, in_opt=False, in_start=False):
        """Check if package is contained in this packdir."""
        if not in_start:
            for p in self.walk('opt'):
                if os.path.basename(p) == pack:
                    return p
        if not in_opt:
            for p in self.walk('start'):
                if os.path.basename(p) == pack:
                    return p

    def header(self, path):
        if ( not DECO or not os.path.exists(path) or not os.listdir(path) ):
            return
        if COLOR:
            blue, yelw, end, bold = ("\33[34m", "\33[33m", "\33[0m", "\33[1m")
            log("\n" + blue + "─" * 67 + end)
            log(bold + blue + "Packs in directory " + yelw + path + "/" + end)
            log(blue + "─" * 67 + end + "\n")
        else:
            log("\n" + "─" * 67)
            log("Packs in directory " + path + "/")
            log("─" * 67 + "\n")

    def walk(self, subdir):
        if ( ONLY_OPT and subdir == 'start' ):
            return []
        if ( ONLY_START and subdir == 'opt' ):
            return []
        if ( os.path.exists(self.path + '/' + subdir) ):
            return glob.iglob(self.path + '/' + subdir + '/*')
        return []

    def output(self, output, subdir):
        """Print the header only if there's some package to display."""
        if ( NO_OUTPUT or not output ):
            return
        if ( not self.has_output_opt and subdir=='opt' and not ONLY_START ):
            self.has_output_opt = True
            self.header(self.path + '/opt')
        if ( not self.has_output_start and subdir=='start' and not ONLY_OPT ):
            self.has_output_start = True
            self.header(self.path + '/start')
        log(output, end='')

    def install(self, repo):
        if not self.has(repo.name):
            repo.process = subprocess.Popen(
                ['git', 'clone', '--depth', '1',
                 '--shallow-submodules', repo.address],
                cwd=self.path + ('/opt' if INSTOPT else '/start'),
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT
            )
            PROCESSING.append(repo)
            if not ASYNC:
                wait(repo)

    #--------------------------------------------------------------------------
    # class commands: methods names have their correspective in Package class
    #--------------------------------------------------------------------------

    def list(self, show_size=None):
        for p in self.walk('opt'):
            self.output(Package(os.path.basename(p)).list(show_size), 'opt')
        for p in self.walk('start'):
            self.output(Package(os.path.basename(p)).list(show_size), 'start')

    def update(self):
        for p in self.walk('opt'):
            Package(os.path.basename(p)).update()
        process_asynch(self, 'opt')
        for p in self.walk('start'):
            Package(os.path.basename(p)).update()
        process_asynch(self, 'start')

    def status(self):
        for p in self.walk('opt'):
            self.output(Package(os.path.basename(p)).status(), 'opt')
        for p in self.walk('start'):
            self.output(Package(os.path.basename(p)).status(), 'start')

    def verbose(self):
        for p in self.walk('opt'):
            self.output(Package(os.path.basename(p)).verbose(), 'opt')
        for p in self.walk('start'):
            self.output(Package(os.path.basename(p)).verbose(), 'start')

    def remotes(self):
        for p in self.walk('opt'):
            self.output(Package(os.path.basename(p)).remotes(), 'opt')
        for p in self.walk('start'):
            self.output(Package(os.path.basename(p)).remotes(), 'start')

    def git(self):
        for p in self.walk('opt'):
            self.output(Package(os.path.basename(p)).git(), 'opt')
        for p in self.walk('start'):
            self.output(Package(os.path.basename(p)).git(), 'start')

    def exe(self):
        for p in self.walk('opt'):
            self.output(Package(os.path.basename(p)).exe(), 'opt')
        for p in self.walk('start'):
            self.output(Package(os.path.basename(p)).exe(), 'start')

    def fetch(self):
        for p in self.walk('opt'):
            Package(os.path.basename(p)).fetch()
        process_asynch(self, 'opt')
        for p in self.walk('start'):
            Package(os.path.basename(p)).fetch()
        process_asynch(self, 'start')

    def move2opt(self):
        opt = color('green', self.path + '/opt/')
        start = color('green', self.path + '/start/')
        if confirm("Move all packages in " + start + "\n%21s" % "to " + opt):
            os.makedirs(opt, exist_ok=True)
            for p in self.walk('start'):
                Package(os.path.basename(p)).move2opt(silent=True)
            self.list(show_size=False)

    def move2start(self):
        opt = color('green', self.path + '/opt/')
        start = color('green', self.path + '/start/')
        if confirm("Move all packages in " + opt + "\n%21s" % "to " + start):
            os.makedirs(start, exist_ok=True)
            for p in self.walk('opt'):
                Package(os.path.basename(p)).move2start(silent=True)
            self.list(show_size=False)


#------------------------------------------------------------------------------
# Repository class
#------------------------------------------------------------------------------


class Repo():
    """Class for remote repositories."""
    def __init__(self, arg):
        self.arg = arg
        self.name = None
        self.user = None
        self.address = None
        self.process = None
        self.timeout = TIMEOUT

    def validate(self):
        """Fill repo information. If repo is valid, return success."""
        gh = 'https://github.com/'
        gl = 'https://gitlab.com/'

        try:
            pack = self.arg.split('/')

            if len(pack) == 2:
                self.user, self.name = pack
                self.address = gh + self.arg

            elif len(pack) == 3:
                site, self.user, self.name = pack
                if site == 'gh':
                    self.address = (gh + self.user + '/' + self.name)
                elif site == 'gl':
                    self.address = (gl + self.user + '/' + self.name)
                else:
                    return False

            elif re.search('^https?://', self.arg):
                self.address = re.sub('(\.git)?/?$', '', self.arg)
                self.name = re.sub('.*/', '', self.address)
                self.user = re.match('.*/([^/]+)/', self.address).group(1)
        except:
            return False
        return True


#------------------------------------------------------------------------------
# HELP
#------------------------------------------------------------------------------


def print_help():
    """Print the help and exit."""
    commands = [
        ['list',        'list packages'],
        ['update',      'update packages'],
        ['install',     'install packages from remote repos'],
        ['status',      'list only packages with a dirty working tree'],
        ['verbose',     'verbose status (with diff)'],
        ['remotes',     'list remotes for packages'],
        ['fetch',       'fetch all remotes'],
        ['git',         'run a single, quoted git command'],
        ['exe',         'run a single, quoted command of any type'],
        ['move2opt',    'move package(s) into the /opt directory'],
        ['move2start',  'move package(s) into the /start directory'],
    ]

    if not HELP:
        commands = commands[:5]

    options = [
        ['-h',          'extended help'],
        ['-nd',         'no decorations (color, headers)'],
        ['-nc',         'no color'],
        ['-no',         'no output (for use inside scripts)'],
        ['-na',         'no async update/cloning'],
        ['-ps',         'print size for "list" subcommand'],
        ['-time',       'timeout for operations (default 15s)'],
        ['-notime',     'no timeout, and no async'],
        ['-opt',        'command only considers opt packages'],
        ['-start',      'command only considers start packages'],
    ]

    options = options[:4] if not HELP else options[1:]

    instopts = [
        ['opt',         'install in /opt directory rather than in /start'],
        ['dir=DIR',     'set base installation directory for packages'],
    ]

    examples = [
        ['List all packages in the pack/my_packs/*/* directories',
         'vpacks list my_packs'],
        ['Verbose status for selected packages',
         'vpacks verbose visual-multi yanktools'],
        ['Run git command',
         'vpacks git "branch --list" my_packs'],
        ['Install a package in the default ("vpacks") directory, as opt type',
         'vpacks install opt mg979/visual-multi'],
        ['Install packages in specific directory',
         'vpacks install dir=my_packs mg979/visual-multi'],
    ]

    print()
    print("Usage:\tvpacks [options] COMMAND [pack | directory]")
    print("\tvpacks [options] install [instopts] REPOS")
    print()
    print("Commands:")
    for c in commands:
        print("\t" + "%-20s" % color('green', c[0]) + c[1])
    print()
    print("Options:")
    for o in options:
        print("\t" + "%-20s" % color('green', o[0]) + o[1])
    print()
    print("Installation options:")
    for o in instopts:
        print("\t" + "%-20s" % color('green', o[0]) + o[1])
    print()
    print("Examples:")
    print()
    for e in examples:
        print('\t' + e[0] + '\n\t' + color('darkgreen', e[1]) + '\n')
    sys.exit()


#------------------------------------------------------------------------------
# GENERIC HELPERS
#------------------------------------------------------------------------------


def error(string):
    """Print an error and exit."""
    print(string)
    sys.exit()


def color(color, string, bold=False, line=False):
    """Print a colored string."""
    if not COLOR:
        return string
    b = '\033[1m' if bold else ''
    l = '\033[4m' if line else ''
    return COLORS[color] + b + l + string + '\033[0m'


def log(string, end='\n'):
    """Print output if allowed."""
    if not NO_OUTPUT and string:
        print(string, end=end)


def clear_screen():
    """Clear the terminal window."""
    if not TERMINAL or NO_OUTPUT or ACTION in ['git']:
        return
    os.system('clear')


def confirm(string):
    """Always return True with -no option."""
    if NO_OUTPUT:
        return True
    print(string + '    ? (y/n)')
    return sys.stdin.read(1) == 'y'


def warning(msg, pack):
    """Issue a warning related to some package."""
    if NO_OUTPUT:
        return True
    log(color('red', 'Warning') + ': ' + msg + ' (' + pack + ')')


def find_packs():
    """Find vim and package directories and basenames."""
    global WARNINGS
    win = os.path.expanduser('~\\vimfiles')
    nwin = os.path.expanduser('~/.vim')
    PACKS['vimdir'] = win if os.path.exists(win) else nwin
    dirpaths = glob.glob(PACKS['vimdir'] + '/pack/*')
    PACKS['dirs'] = {os.path.basename(folder): folder for folder in dirpaths}
    packpaths = glob.glob(PACKS['vimdir'] + '/pack/*/*/*')
    PACKS['packs'] = {}

    for packpath in packpaths:
        key = os.path.basename(packpath)
        if key in PACKS['packs']:
            WARNINGS.append(('duplicated package', key))
        else:
            PACKS['packs'][key] = packpath

    for dir in PACKS['dirs']:
        for pack in PACKS['packs']:
            if pack == dir:
                msg = 'a package with the same name of a directory exists'
                WARNINGS.append((msg, pack))


def wait(pack):
    """Wait for process to terminate, handle TimeoutError."""
    try:
        pack.process.wait(timeout=TIMEOUT)
    except TimeoutError:
        timeout(pack.name)


def timeout(name):
    """Log warning when timeout has been reached."""
    log("%-30s" % (name + ': ') + color('red', "timeout %ds" % int(TIMEOUT)))


#------------------------------------------------------------------------------
# COMMAND-LINE ARGUMENTS PARSING
#------------------------------------------------------------------------------


def walk_arg(arg):
    """Process arguments and build actions queue."""
    if ( arg in PACKS['dirs'] ):
        QUEUE.append(Packdir(arg))
    elif ( arg in PACKS['packs'] ):
        QUEUE.append(Package(arg))
    else:
        error('Pack or pack directory not found.')


def parse_args():
    """Parse arguments."""
    global ACTION, DECO, SHOW_SIZE, NO_OUTPUT, INSTALL, ASYNC, EXE, COLOR, HELP
    global TERMINAL, ONLY_START, ONLY_OPT, TIMEOUT
    args = sys.argv[1:]

    while ( args ):
        if (args[0] in ['-h', '-nd', '-nc', '-ps', '-no',
                        '-notime', '-opt', '-start']):

            if   ( args[0] == '-h'      ): HELP = True
            elif ( args[0] == '-nd'     ): DECO = False
            elif ( args[0] == '-nc'     ): COLOR = False
            elif ( args[0] == '-ps'     ): SHOW_SIZE = True
            elif ( args[0] == '-no'     ): NO_OUTPUT = True
            elif ( args[0] == '-notime' ): TIMEOUT, ASYNC = None, False
            elif ( args[0] == '-opt'    ): ONLY_OPT = True
            elif ( args[0] == '-start'  ): ONLY_START = True

            del args[0]
            continue

        if ( args[0] == '-na' ):
            ASYNC = False
            if TIMEOUT and TIMEOUT == 15:
                TIMEOUT = 20
            del args[0]
            continue

        if ( args[0] == '-time' ):
            del args[0]
            if ( args ):
                TIMEOUT = int(args.pop(0))
                continue
            else:
                print_help()

        # exit loop when the first arg is found, that isn't an option
        break

    if ( not args ):
        print_help()

    ACTION = args.pop(0)
    TERMINAL = sys.stdout.isatty()
    COLOR = not NO_OUTPUT and COLOR and DECO

    if ( ACTION not in ACTIONS ):
        print_help()

    if ( ACTION == 'install' ):
        INSTALL = True
        parse_install(args)
        return

    if ( ACTION in ['git', 'exe'] ):
        if ( not args ):
            print_help()
        EXE = args.pop(0)


    # if no args beyond the command, perform on all packages, in all dirs
    # otherwise perform on args (they could be single packages, or directories)
    if ( not args ):
        for path in glob.iglob(PACKS['vimdir'] + '/pack/*'):
            walk_arg(os.path.basename(path))
    else:
        for arg in args:
            walk_arg(arg)


def parse_install(args):
    """Parse arguments that follow an 'install' subcommand."""
    global INSTDIR, INSTOPT

    for arg in args:
        if ( arg == 'opt' ):
            INSTOPT = True

        elif ( re.search('^dir=\w+', arg) ):
            INSTDIR = arg.replace('dir=', '')

        else:
            QUEUE.append(arg)


#------------------------------------------------------------------------------
#   INSTALL QUEUE PROCESSING
#------------------------------------------------------------------------------


def clone_output(out):
    if ( re.search('\nfatal:', out) ):
        return re.sub('fatal:', color('red', 'fatal') + ':', out)
    else:
        return out


def process_clones():
    """Handle asynch package installation."""
    start = time()
    while ( PROCESSING ):
        i = 0

        # --------------------

        for repo in PROCESSING:
            if TIMEOUT and repo.timeout < 0:
                timeout(repo.name)
                repo.process.terminate()
                del PROCESSING[i]
                break
            if repo.process.poll() is not None:
                out = repo.process.communicate()[0].decode('utf-8')
                name = color('green', repo.user + '/' + repo.name)
                log(name + ': ' + clone_output(out))
                del PROCESSING[i]
                break
            if TIMEOUT:
                passed = time() - start
                repo.timeout -= passed
                start += passed
            i += 1

        # --------------------

        if ( PROCESSING ):
            sleep(0.2)


def install_packages():
    """Process the install queue."""
    pdir = Packdir(INSTDIR)
    pdir.ensure_exists()
    instdir = pdir.path + ('/opt' if INSTOPT else '/start')

    for q in QUEUE:
        repo = Repo(q)
        if not repo.validate():
            continue

        if repo.name in PACKS['packs']:
            name = color('green', repo.user + '/' + repo.name)
            dr = PACKS['packs'][repo.name].replace(PACKS['vimdir'], '')
            log(name + ': already installed in ..' + dr)
        elif not pdir.has(repo.name):
            pdir.install(repo)
        else:
            name = color('green', repo.user + '/' + repo.name)
            log(name + ': already installed in ' + pdir.path)

    process_clones()


#------------------------------------------------------------------------------
#   ACTION QUEUE PROCESSING
#------------------------------------------------------------------------------


def process_asynch(packdir=None, subdir=None):
    """Handle asynch package processing."""
    update = ACTION == 'update'
    start = time()
    while ( PROCESSING ):
        i = 0

        # --------------------

        for pack in PROCESSING:
            if TIMEOUT and pack.timeout < 0:
                timeout(pack.name)
                pack.process.terminate()
                del PROCESSING[i]
                break
            if pack.process.poll() is not None:
                cmd = pack.process.communicate()
                cmd = [cmd[0].decode('utf-8'), cmd[1].decode('utf-8')]
                if packdir:
                    # output is managed by Packdir class
                    packdir.output(pack.output(cmd, updating=update), subdir)
                else:
                    # query for single packs, no Packdir calls
                    log(pack.output(cmd, updating=update))
                del PROCESSING[i]
                break
            if TIMEOUT:
                passed = time() - start
                pack.timeout -= passed
                start += passed
            i += 1

        # --------------------

        if ( PROCESSING ):
            sleep(0.2)


def process_action():
    """
    Process the queue for the requested action.

    Each element of the queue is either a packages directory, or a single
    package. Their public methods' names are the same, so they can be called in
    either case.
    """
    for q in QUEUE:
        actions = {
            'list': q.list,
            'update': q.update,
            'status': q.status,
            'verbose': q.verbose,
            'remotes': q.remotes,
            'fetch': q.fetch,
            'git': q.git,
            'exe': q.exe,
            'move2opt': q.move2opt,
            'move2start': q.move2start
        }
        log ( actions[ACTION]() )

    # packages may have been queued for async processing
    process_asynch()


#------------------------------------------------------------------------------
#   MAIN QUEUE PROCESSING
#------------------------------------------------------------------------------


def main():
    """Main function."""
    find_packs()            # find packages and their directories
    parse_args()            # build the action/installation queue
    clear_screen()          # clear the screen if appropriate

    if INSTALL:
        install_packages()
    else:
        process_action()

    if not NO_OUTPUT:       # leave an empty line at the end
        print()

    for msg in WARNINGS:
        warning(msg[0], msg[1])


if __name__ == '__main__':
    main()

